## Low latency canvas notes

### Background

Low latency canvas is a canvas context attribute that allows web developers to opt in to a new mode of canvas rendering that provides the lowest possible latency ([chromestatus](https://www.chromestatus.com/feature/6360971442388992), [WebGL](https://github.com/KhronosGroup/WebGL/pull/2753) and [2D](https://github.com/whatwg/html/pull/4234) spec PRs). The main goal of the flag is to remove the latency introduce by the operating systems compositor. A side effect of this is that the presentation of the rendered contents of the canvas is decoupled from the rest of the page, such that the canvas content rendered during a specific frame may show up on the screen before other non-canvas updates during that same frame.

On non-Windows platforms where there is planned support (ChromeOS and MacOS), it looks like low latency canvas support is driving towards allowing the web page to render directly into the front buffer when possible - this results in tearing, which may be acceptable for certain types of applications (e.g. ink). There do not appear to be any plans for controlling the tearing aspect of the flag - the assumption being that web developers that use the flag are prepared for (or even desire) tearing for their canvas rendering. It would be good to know whether this is the intention of the Chromium developers as it would change approaches to the presentation model.

### Implementation considerations on Windows

As of today, as far as I am able to determine, the Chromium project currently has no plans for an implementation on Windows. The only reference to a Windows implementation involves a [DX9 flag](https://github.com/whatwg/html/issues/2659#issuecomment-300580747) that is not compatible with the default angle backend for Chromium and also has the side effect of disabling DWM on Windows - this is not a viable solution.

On Windows, the closest thing we have to rendering to a front buffer is Multiplane-overlays (MPO). These correspond to hardware/driver supported buffers that are not composed by DWM. The only way to take advantages of these planes is to use a [flip model swap chain that satisfies some constraints](https://blogs.msdn.microsoft.com/directx/2018/04/09/dxgi-flip-model/). Using a swap chain for canvas' marked with the low latency flag will decouple the presentation of a canvas from the rest of the browser, and provide a few presentation model options (discussed below) to improve latency. There is already some support for overlay swap chains on Windows in Chromium's surface code. There are heuristics that consume the properties of the quads to be drawn and promote them - currently appears to be limited to video-based quads. More investigation would need to be completed to connect the dots here.

In Chromium, the low latency flag also modifies how certain types of input are dispatched. Chromium normally [coalesces input](https://developers.google.com/web/updates/2017/06/aligning-input-events), and dispatches the relevant events to script at the beginning of the process to produce a frame. This saves on battery life/CPU consumption, but comes at the cost of increased latency. Opting in to low latency canvas disables this behavior and input is dispatched as soon as possible, potentially multiple times per frame. The low latency canvas code is written such that any updates to the canvas are submitted as a compositor frame (we can think about this as an 'implicit commit') after the currently running task on the javascript thread completes.

#### Presentation model

The implicit commit model has some implications on how the swapchain will be presented. The swapchain [Present APIs](https://docs.microsoft.com/en-us/windows/desktop/api/dxgi1_2/nf-dxgi1_2-idxgiswapchain1-present1) takes the sync interval as its first parameter. The sync interval determines when the contents of the back buffer just presented should be picked up. One common approach for presenting swapchains is to use sync interval 1 with two buffers (one back, one front). The Vsync is then used as a signal to produce a frame, and only one frame per-vsync is used. If a second Present happens before the first is picked up by DWM/hardware it will block until the front buffer is no longer in use (i.e. until the next vsync) and no buffer will be available for the application to draw into. One technique to sidestep this issue is to use a triple buffered swap chain, where the front buffer is in use, one back buffer is complete and pending presentation, and a third buffer is available for further rendering (which, if factors align, can get presented before the next Vsync and reduce latency).

The other approach is to use sync interval 0 with the DXGI_PRESENT_ALLOW_TEARING flag set on the swapchain. This allows unbounded presents, by releasing the front buffer being used for scan out at the next Hsync and picking up the Presented back buffer. This would introduce tearing the previous frame could have been half scanned out before the new one starts to be scanned out in the middle of the frame. One caveat is that if you don't have an MPO swap chain, you won't actually achieve tearing - instead you'll essentially have unbounded presents until the next Vsync, at which point, DWM will wake up, grab the last presented buffer, and start consuming it as input on the GPU for composing the screen. During this operation, further Presents will be blocked, but will be unblocked once that GPU work is complete (i.e. doesn't wait for DWM Flip to complete, which we see when using sync interval 1).

Options for low latency canvas:
If we prefer to achieve tearing when possible, we should Present with sync interval 0 and allow tearing. This maps closest to the 'implicit commit' model - using sync interval 1 would require us to bake in some heuristics regarding when we actually call Present in response to one of these compositor frames being submitted, since doing so too often would result in higher latency and blocking threads. Sync interval 0 also has the nice side effect that we get some latency benefits even if MPO is not enabled, and don't have to detect changes to the MPO status and modify our presentation model in response, which would be a tricky proposition.

#### Other considerations and open questions
Being an MPO is not a static property of the swap chain. There are a limited number of these planes available, so things like presentation rate, window foreground status, etc., may control whether a given swap chain gets MPO, and other factors such as required blending with non-opaque windows (e.g. 'frosted' content on top) can dynamically move swapchains from MPO to composed and back again.

For non-retained drawing modes (e.g. WebGL with preserveDrawingBuffer:false), it's not clear whether achieving 0-copy 'rendering into the front buffer' functionality is possible. Conceptually, we can consider rendering directly into the back buffer, then presenting, but as far as I can tell the abstractions in Chromium don't really blend the hardware GPU buffer with the overlay plane concept. Perhaps more investigation could reveal a viable approach.

MPO is only supported on Windows 8.1 and above, and Win7 will never be supported. On Windows versions that do support MPO, hardware support to date has generally been limited to Intel GPUs (.

Memory for swapchains can be expensive - we'll be paying 2x the size of the canvas, which can also multiply during resize scenarios.

